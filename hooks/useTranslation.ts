import { useState, useRef } from 'react';
import { initLlama, LlamaContext } from 'llama.rn';
import AsyncStorage from '@react-native-async-storage/async-storage';

export function useTranslation() {
  const [isTranslating, setIsTranslating] = useState(false);
  const [isModelLoaded, setIsModelLoaded] = useState(false);
  const [modelError, setModelError] = useState<string | null>(null);
  const llamaContextRef = useRef<LlamaContext | null>(null);

  const initializeModel = async () => {
    try {
      if (llamaContextRef.current) {
        return llamaContextRef.current;
      }

      // Check if model is already cached
      const modelPath = await AsyncStorage.getItem('translation_model_path');
      
      if (!modelPath) {
        throw new Error('No translation model found. Please download a GGUF model first.');
      }

      console.log('Initializing LLaMA with model:', modelPath);

      // Initialize LLaMA with the model
      const context = await initLlama({
        model: modelPath,
        use_mlock: true,
        n_ctx: 2048,
        n_batch: 512,
        n_threads: 4,
        embedding: false,
        n_gpu_layers: 0, // Set to 0 for CPU-only inference
      });

      llamaContextRef.current = context;
      setIsModelLoaded(true);
      setModelError(null);
      console.log('LLaMA model initialized successfully');
      return context;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('Failed to initialize translation model:', errorMessage);
      setModelError(errorMessage);
      setIsModelLoaded(false);
      throw error;
    }
  };

  const translateText = async (
    text: string,
    fromLanguage: string,
    toLanguage: string
  ): Promise<string> => {
    if (!text.trim()) {
      return '';
    }

    setIsTranslating(true);

    try {
      // Try to get fallback translation first for common phrases
      const fallbackTranslation = getFallbackTranslation(text, fromLanguage, toLanguage);
      if (fallbackTranslation) {
        console.log('Using fallback translation for:', text);
        return fallbackTranslation;
      }

      const context = await initializeModel();

      // Language code to full name mapping
      const languageNames: Record<string, string> = {
        'en': 'English',
        'es': 'Spanish',
        'fr': 'French',
        'de': 'German',
        'it': 'Italian',
        'pt': 'Portuguese',
        'ru': 'Russian',
        'ja': 'Japanese',
        'ko': 'Korean',
        'zh': 'Chinese',
        'ar': 'Arabic',
        'hi': 'Hindi',
      };

      const fromLangName = languageNames[fromLanguage] || fromLanguage;
      const toLangName = languageNames[toLanguage] || toLanguage;

      // Create a more specific translation prompt
      const prompt = `You are a professional translator. Translate the following text from ${fromLangName} to ${toLangName}. Provide only the translation without any explanations, quotes, or additional text.

Text: ${text}

Translation:`;

      console.log('Translating with LLaMA:', { text, fromLangName, toLangName });

      // Generate translation using LLaMA
      const result = await context.completion({
        prompt,
        n_predict: 128,
        temperature: 0.1,
        top_p: 0.9,
        top_k: 40,
        penalty_repeat: 1.1,
        stop: ['\n\n', 'Text:', 'Translation:', '\n---'],
      });

      // Extract and clean the translation
      let translation = result.text || '';
      
      // Clean up the translation
      translation = translation.trim();
      
      // Remove any remaining prompt artifacts
      translation = translation.replace(/^Translation:\s*/i, '');
      translation = translation.replace(/^["']|["']$/g, ''); // Remove quotes
      translation = translation.split('\n')[0]; // Take only the first line
      
      if (!translation) {
        throw new Error('No translation generated by the model');
      }

      console.log('Translation result:', translation);
      return translation;
    } catch (error) {
      console.error('Translation error:', error);
      
      // Enhanced fallback for any error
      const fallbackTranslation = getFallbackTranslation(text, fromLanguage, toLanguage);
      if (fallbackTranslation) {
        console.log('Using fallback translation due to error');
        return fallbackTranslation;
      }
      
      // If no fallback available, return a helpful error message
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Translation failed: ${errorMessage}`);
    } finally {
      setIsTranslating(false);
    }
  };

  const getFallbackTranslation = (text: string, fromLang: string, toLang: string): string | null => {
    // Enhanced fallback dictionary for common phrases
    const fallbackDict: Record<string, Record<string, string>> = {
      'hello': {
        'es': 'hola',
        'fr': 'bonjour',
        'de': 'hallo',
        'it': 'ciao',
        'pt': 'olá',
        'ru': 'привет',
        'ja': 'こんにちは',
        'ko': '안녕하세요',
        'zh': '你好',
        'ar': 'مرحبا',
        'hi': 'नमस्ते',
      },
      'thank you': {
        'es': 'gracias',
        'fr': 'merci',
        'de': 'danke',
        'it': 'grazie',
        'pt': 'obrigado',
        'ru': 'спасибо',
        'ja': 'ありがとう',
        'ko': '감사합니다',
        'zh': '谢谢',
        'ar': 'شكرا',
        'hi': 'धन्यवाद',
      },
      'goodbye': {
        'es': 'adiós',
        'fr': 'au revoir',
        'de': 'auf wiedersehen',
        'it': 'arrivederci',
        'pt': 'tchau',
        'ru': 'до свидания',
        'ja': 'さようなら',
        'ko': '안녕히 가세요',
        'zh': '再见',
        'ar': 'وداعا',
        'hi': 'अलविदा',
      },
      'yes': {
        'es': 'sí',
        'fr': 'oui',
        'de': 'ja',
        'it': 'sì',
        'pt': 'sim',
        'ru': 'да',
        'ja': 'はい',
        'ko': '네',
        'zh': '是',
        'ar': 'نعم',
        'hi': 'हाँ',
      },
      'no': {
        'es': 'no',
        'fr': 'non',
        'de': 'nein',
        'it': 'no',
        'pt': 'não',
        'ru': 'нет',
        'ja': 'いいえ',
        'ko': '아니요',
        'zh': '不',
        'ar': 'لا',
        'hi': 'नहीं',
      },
      'please': {
        'es': 'por favor',
        'fr': 's\'il vous plaît',
        'de': 'bitte',
        'it': 'per favore',
        'pt': 'por favor',
        'ru': 'пожалуйста',
        'ja': 'お願いします',
        'ko': '부탁합니다',
        'zh': '请',
        'ar': 'من فضلك',
        'hi': 'कृपया',
      },
      'excuse me': {
        'es': 'disculpe',
        'fr': 'excusez-moi',
        'de': 'entschuldigung',
        'it': 'scusi',
        'pt': 'com licença',
        'ru': 'извините',
        'ja': 'すみません',
        'ko': '실례합니다',
        'zh': '对不起',
        'ar': 'عذرا',
        'hi': 'माफ करें',
      },
      'how are you': {
        'es': '¿cómo estás?',
        'fr': 'comment allez-vous?',
        'de': 'wie geht es dir?',
        'it': 'come stai?',
        'pt': 'como você está?',
        'ru': 'как дела?',
        'ja': '元気ですか?',
        'ko': '어떻게 지내세요?',
        'zh': '你好吗?',
        'ar': 'كيف حالك؟',
        'hi': 'आप कैसे हैं?',
      },
    };

    const lowerText = text.toLowerCase().trim();
    return fallbackDict[lowerText]?.[toLang] || null;
  };

  const releaseModel = async () => {
    if (llamaContextRef.current) {
      try {
        await llamaContextRef.current.release();
        console.log('LLaMA model released');
      } catch (error) {
        console.error('Error releasing model:', error);
      }
      llamaContextRef.current = null;
      setIsModelLoaded(false);
    }
  };

  return {
    translateText,
    isTranslating,
    isModelLoaded,
    modelError,
    releaseModel,
    initializeModel,
  };
}